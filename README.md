# 🚗 라인트래킹 자동차 시스템 (Raspberry Pi & Arduino)

본 프로젝트는 라즈베리파이와 아두이노를 이용하여 실시간 영상 기반의 라인트래킹 자동차를 구현하는 것을 목표로 합니다. 라즈베리파이는 카메라 영상을 획득하고 처리하여 라인을 검출하고 주행 방향을 결정하며, 이를 기반으로 아두이노에 조향 및 구동 명령을 전달합니다. 아두이노는 RC 신호 입력 처리 및 라즈베리파이로부터 받은 제어 명령을 기반으로 실제 자동차의 조향과 속도를 제어합니다. 웹 기반의 실시간 스트리밍과 상태 모니터링 시스템을 통해 사용자 친화적인 원격 제어 환경을 제공합니다.
유튜브 동작 영상 : https://www.youtube.com/shorts/V9vbhLZwnFo

---

## 👥 팀 구성원

|  이름  | 담당 업무                                                                      |
| ----- | -------------------------------------------------------------------------- |
| 윤석권 | 아두이노: RC 신호 입력 처리, 서보모터 및 ESC 제어, 라즈베리파이와의 UART 통신 구현                      |
| 유태영 | 라즈베리파이: 카메라 영상 캡처 및 처리, 라인 인식 알고리즘 구현, 웹 대시보드 및 스트리밍 구현, 아두이노와의 UART 통신 구현 |

---

## 📍 아두이노 핀 구성 요약

| 기능                    | 핀 번호   | 설명             |
| --------------------- | ------ | -------------- |
| 조향 서보 PWM 출력          | Pin 9  | 조향 서보 제어       |
| 전진/후진 PWM 출력 (ESC)    | Pin 10 | ESC(모터) 제어용    |
| RC 수신기 조향 입력 (CH1)    | A0     | RC 수신기의 CH1 연결 |
| RC 수신기 전진/후진 입력 (CH2) | A1     | RC 수신기의 CH2 연결 |
| 방향 지시등 (좌측)           | Pin 7  | 좌회전 시 LED 점등   |
| 방향 지시등 (우측)           | Pin 8  | 우회전 시 LED 점등   |
| 자동/수동 모드 전환 스위치       | Pin 12 | 자동/수동 모드 전환 입력 |

---
## 📍 rc카 구성
| ![image](images/up.png) | ![image](images/front.png) | ![image](images/right.png) | ![image](images/led.png) |
| :---------------------: | :----------------------: | :-----------------------: | :---------------------: |
| 상단(Top View)     | 앞  (Front View)    | 옆  (Side View)   | 후방 LED(Rear LED Indicator) |

## 📂 소스별 동작 요약

### ✅ 라즈베리파이 `main.py`

| 단계       | 기능 요약                                            |
| -------- | ------------------------------------------------ |
| 카메라 초기화  | `Picamera2` 320×240 @≈100 Hz 캡처                  |
| 영상 전처리   | Gray → GaussianBlur → Threshold(BINARY\_INV)     |
| ROI 설정   | 프레임 하단 60 – 75 % 영역만 검사                          |
| 라인 위치 계산 | `findContours` + `moments` → 중심(cₓ) 산출           |
| 방향 판정    | 5단계 (LEFT\_HARD/LEFT/STRAIGHT/RIGHT/RIGHT\_HARD) |
| 명령 송신    | 시리얼 문자 전송 & WebSocket JPEG 스트림 배포                |
---

## 🖼️ 이미지 처리 · 라인트레이싱 제어

### 1️⃣ 전처리 & ROI 설정

* **흑백 변환 → 가우시안 블러 → 역이진화**로 노이즈를 최소화하고 라인을 선명하게 추출합니다.
* 해상도 320×240 중 \*\*하단 15 % (60 – 75 %)\*\*만 관심 영역(ROI)으로 삼아 계산량을 줄이고 오검출을 방지합니다.

### 2️⃣ 라인 검출 및 중심 좌표 계산

* `cv2.findContours`로 ROI 안의 흰색 객체(라인)를 모두 찾습니다.
* **최대 면적** 컨투어를 실제 주행 라인으로 간주하고, `cv2.moments`로 **무게중심(cₓ)** 을 계산합니다.

### 3️⃣ 방향 결정 로직 (5‑State FSM)

| 구간 경계                  | 방향 상태           |
| ---------------------- | --------------- |
| `cₓ < 0.25·W`          | **LEFT\_HARD**  |
| `0.25·W ≤ cₓ < 0.40·W` | **LEFT**        |
| `0.40·W ≤ cₓ ≤ 0.60·W` | **STRAIGHT**    |
| `0.60·W < cₓ ≤ 0.75·W` | **RIGHT**       |
| `cₓ > 0.75·W`          | **RIGHT\_HARD** |

> HARD/Soft 2‑레벨 분류로 미세 조향과 급조향을 구분해 드리프트를 최소화합니다.

### 4️⃣ 시리얼 명령 매핑

| 상태          | 기본 가속 | 조향 문자 |
| ----------- | ----- | ----- |
| STRAIGHT    | `f`   | `s`   |
| LEFT        | `f`   | `l`   |
| RIGHT       | `f`   | `r`   |
| LEFT\_HARD  | `f`   | `L`   |
| RIGHT\_HARD | `f`   | `R`   |

* **중복 전송 차단**: 직전 전송 문자와 동일하면 생략해 UART 대역폭 절약.
* **ESC 가속 유지**: 매 주기 `f`(가속 유지) → 스티어링 문자 순으로 전송.

### 5️⃣ 라인 유실 복구 전략

1. 라인이 ‘NO LINE’으로 판정되면 **1회만** 복구 루틴 실행.
2. 직전 논리 방향이 좌측이면 우측(`r`)으로 반대 방향 휙 꺾기, 우측이면 좌측(`l`) 반전.
3. 짧은 후진(`b`)으로 라인을 재검색 → 라인 복구 시 정상 FSM 복귀.

### 🔑 핵심 파라미터

| 항목        | 기본값                           | 비고                        |
| --------- | ----------------------------- | ------------------------- |
| Threshold | 150                           | 조명·노면에 따라 120 – 180 범위 권장 |
| ROI (%)   | 60 – 75                       | 노면만 집중, 필요 시 50 – 80 재조정  |
| FSM 경계    | 0.25 / 0.40 / 0.60 / 0.75 · W | 차량 폭·카메라 FOV에 맞춰 조절       |
| 주기        | 10 ms                         | ≈100 Hz 처리 목표 (RPi 4 기준)  |


### 📄 발췌 코드 (요약)

```python
# === 전처리 ===
gray  = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
gray  = cv2.GaussianBlur(gray, (5, 5), 0)
_, bin = cv2.threshold(gray, 150, 255, cv2.THRESH_BINARY_INV)
roi   = bin[int(HEIGHT*0.60): int(HEIGHT*0.75), :]

# === 라인 검출 ===
contours, _ = cv2.findContours(roi, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
latest_direction = "NO LINE"
if contours:
    M = cv2.moments(max(contours, key=cv2.contourArea))
    if M["m00"]:
        cx = int(M["m10"] / M["m00"])
        # FSM 분기 (상세 표 참고)
```
 